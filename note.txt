Youtube name -> Great Stack

Express JS Full Course from beginner to pro 2025



Connecting to Datbase code
___________________________

-------index.js-----------

import express from "express";
import { connectDB } from "./config/db.js";
import { Person } from "./models/Person.js";

const app = express();
const PORT = 3000;

await connectDB();

app.use(express.json());

// Define a simple route
app.get("/", (req, res) => {
  res.send("Hello Express");
});

// Saving data in mongoDB
app.post("/person", async (req, res) => {
  try {
    const { name, age, email } = req.body;
    const newPerson = new Person({
      name,
      age,
      email,
    });
    await newPerson.save();
    console.log(newPerson);
    res.send("Person data Added");
  } catch (error) {
    res.send(error.message);
  }
});

// Updating data in mongodb
app.put("/person", async (req, res) => {
  const { id } = req.body;

  const personData = await Person.findByIdAndUpdate(id, { age: 28 }); // .findOne for single entry, .findById for id based search

  console.log(personData);

  res.send("Person data updated");
});

//Deleting data in mongodb
app.delete("/person/:id", async (req, res) => {
  const { id } = req.params;

  const personData = await Person.findByIdAndDelete(id);

  console.log(personData);

  res.send("Person data deleted");
});

// app.get("/person", (req, res) => {
//   res.send(req.body);
// });

app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});





------Cookies-------

npm install cookie-parser
___________________________


Cookies are small data files sent from the server to the client, stored on the client's browser. They are sent back with every request to the server.


Uses of Cookies

-> Session Management - Maintaining user login sessions.
-> Personalization - Enhancing user experience with recommendations
-> User Tracking - Monitoring user behavior on the website




------ Sessions -------

npm install express-session
____________________________

HTTP is stateless, meaning each request is independent and does not retain user data.

To persist data between requests, we can use: 

-> Cookies - Stored on the client, visible to users.
-> URL Parameters - Can be manipulated and exposed.

Sessions solve this problem by storing user data on the server and associating it with a unique Session ID, which is stored on the client as a cookie.




---- Authentication in ExpressJS -----

Authentication is the process of verifying the identity of a user. In ExpressJS, authentication ensures that only authorized users can accesss certain resources.

2 ways to implement authentication: 
____________________________________

-> Session-Based Authentication (Uses cookies and Sessions)
-> Token-Based Authentication (Uses JWT or OAuth tokens)


The basic authentication flow:

  1. The user sends login credentials (email/password)
  2. The server verifies the credentials against a database.
  3. If valid, the server responds with a session (cookie) or a JWT token.
  4. The client stores this session or token for subsequent requests.
  5. For each request, the client sends the session/token for verification.



JWT-based Authentication

npm i jsonwebtoken
____________________

npm i bcryptjs
____________________

JWT (JSON Web Token) is a stateless authentication method that sends a token instead of storing sessions on the server

How JWT Works:

  1. The user logs in and recieves a JWT token.
  2. The client stores the token (in localStorage or Authorization Header)
  3. The token is sent with every request
  4. The server verifies the token and allows access.


Code:

  const users = [];

  app.post("/register", async (req, res) => {
    const { username, password } = req.body;
    const hashedPassword = await bcrypt.hash(password, 10);
    users.push({
      username,
      hashedPassword,
    });
    res.send("User registered");
  });

  app.post("/login", async (req, res) => {
    const { username, password } = req.body;
    const user = users.find((u) => u.username === username);
    if (!user || !(await bcrypt.compare(password, user.hashedPassword))) {
      return res.send("Invalid credentials");
    }
    const token = jwt.sign({ username }, "test#secret");
    res.json({ token });
  });

  app.get("/dashboard", (req, res) => {
    try {
      const token = req.header("Authorization");
      const decodedToken = jwt.verify(token, "test#secret");
      if (decodedToken.username) {
        return res.send(`Welcome to your dashboard, ${decodedToken.username}`);
      } else {
        res.send("Access Denied");
      }
      res.send(`Welcome to your dashboard, ${decodedToken.username}`);
    } catch (err) {
      res.send("Invalid Token");
    }
  });




------ RESTful APIs with ExpressJS -------

A RESTful API is a web service that follows REST principles, using HTTP methods to perform action on resources.


REST API PRINCIPLES
____________________

1 Statless
-> Every request from the client must contain all the necessary information.

2 Client-Server ARchitecture
-> The frontend and backend communicate via a well-defined API.

3 Resource-based
-> Everything is treated as a resource (e.g. users, products, orders), each with a unique URL.

4 HTTP Methods for CRUD Operations

-> 

HTTP Method        Action                Example EndPoint

GET               Read Data              /api/product/list
POST              Create Data            /api/product/add
PUT               Update Data            /api/product/update
DELETE            Deleta Data            /api/product/del/:id




Use Proper HTTP Status Codes 

Each status belongs to a particular class, which conveys the type of responses:

2xx (Success): These codes indicate that the request was successfully processed by the server

  -> 200 OK : The request was successful, and the server has sent back the requested data (for GET requests).
  -> 201 Created : The resource was successfully created (for POST requests)
  -> 204 No Content : The request was successful, but there's no data to return (commonly used for DELETE or PUT requests).

4xx (Client Errors): These codes indicate that there was an issue with the client's request, meaning the client needs to fix something

  -> 400 Bad Request: The server cannot process the request due to bad syntax.
  -> 401 Unauthorized: The request lacks valid authentication credentials.
  -> 403 Forbidden: The server understood the request, but if refuse to authorize it.
  -> 404 Not Found: The requested resource was not found on the server.
  -> 422 Unprocessable Entry: The server understands the content type and syntax, but the request cannot be processed (often used in validation errors)

5xx (Server Errors): These codes indicate that the server has failed to fulfill a valid request.

  -> 500 Internal Server Error : A generic error message when the server encounters an unexpected condition.
  -> 502 Bad Gateway: The server recieved an invalid response from an upstream server.
  -> 503 Service Unavailable : The server is currently unavailable (e.g. due to overloaded or down for maintenance)

Why Status Codes Matter:

  -> Clarity: They give the client or user a clear indication of what happened with the request.
  -> Error Handling: They allow the client to properly handle different kinds of errors (e.g. retryingthe request or notifying the user).
  -> Standardization : They provide a consistent way to communicate results across different APIs, making it easier for developers to work with APIs.

In short, status codes are necessary to help the client understand the outcome of the request and to hanlde any issues accordingly.




